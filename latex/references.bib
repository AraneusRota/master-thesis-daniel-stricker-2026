@article{abc12,
	Author = {Max Mustermann},
	Date-Added = {2012-11-14 15:48:16 +0000},
	Date-Modified = {2012-11-14 15:48:47 +0000},
	Journal = {Journal XY},
	Title = {A Paper With A Title},
	Year = {2012}
}

@article{lantern,
    Author = {Fei Wang and Daniel Zheng and James Decker and Xilun Wu and Grégory M. Essertel and Tiark Rompf},
    Title = {Demystifying Differentiable Programming: Shift/Reset the Penultimate Backpropagator}, 
    Year = {2019}
}


@online{tudapub,
	title={TUDaPub – \LaTeX-Paper im Corporate Design der TU Darmstadt},
	author={Marei Peischl},
	date={2020-10-05},
	url={http://mirrors.ctan.org/macros/latex/contrib/tuda-ci/doc/DEMO-TUDaPub.pdf},
	urldate={2020-10-05}
}




lambda-x-projection.png

chorlean: type- and effect-safe functional choreographies



@misc{klor,
    author = {lovrosdu and sungshik},
    title = {klor},
    year = {2024},
    publisher = {GitHub},
    journal = {GitHub repository},
    howpublished = {\url{https://github.com/lovrosdu/klor}},
    commit = {991c9ad5867ef85c1d09e50b2f0090fb30257603}
}

@misc{chorleanrepo,
title={Private ChorLean code repository},
author={Simon Daniel and van-den-Berg and Daniel Stricker},
note={Privately shared access to me},
    year={2025}
}

@misc{chorleanpaper,
    title={Private ChorLean article},
    author={Simon Daniel et al.},
    note={Privately shared access to me},
    year = {2025},
}

@article{giallorenzo2021multiparty,
    Author = {Saverio Giallorenzo and Fabrizio Montesi and Marco Peressotti and David Richter and Guido Salvaneschi and Pascal Weisenburger},
    Title = {Multiparty Languages: The Choreographic and Multitier Cases},
    Journal = {Leibniz International Proceedings in Informatics (LIPIcs)},
    Volume = {194},
    Pages = {22:1--22:27},
    Year = {2021},
    Editor = {Anders M{\o}ller and Manu Sridharan},
    Publisher = {Schloss Dagstuhl -- Leibniz-Zentrum für Informatik},
    Address = {Dagstuhl, Germany},
    DOI = {10.4230/LIPIcs.ECOOP.2021.22},
    URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2021.22},
    ISBN = {978-3-95977-190-0},
    ISSN = {1868-8969},
    Note = {35th European Conference on Object-Oriented Programming (ECOOP 2021), Keywords: Distributed Programming, Choreographies, Multitier Languages}
}

@article{jacobs2021connectivity,
    Author = {Jules Jacobs and Stephanie Balzer and Robbert Krebbers},
    Title = {Connectivity Graphs: A Method for Proving Deadlock Freedom Based on Separation Logic (Artifact)},
    Journal = {Zenodo},
    Year = {2021},
    DOI = {10.5281/zenodo.5675249},
    URL = {https://zenodo.org/records/5675249}
}

@article{Shen_2023,
    title={HasChor: Functional Choreographic Programming for All (Functional Pearl)},
    volume={7},
    ISSN={2475-1421},
    url={http://dx.doi.org/10.1145/3607849},
    DOI={10.1145/3607849},
    number={ICFP},
    journal={Proceedings of the ACM on Programming Languages},
    publisher={Association for Computing Machinery (ACM)},
    author={Shen, Gan and Kashiwa, Shun and Kuper, Lindsey},
    year={2023},
    month=aug, pages={541–565}
}


@article{dagand2025lisp,
    Author = {Pierre-Evariste Dagand and Frederic Peschanski},
    Title = {The Lisp in the Cellar},
    Journal = {Zenodo},
    Year = {2025},
    DOI = {10.5281/zenodo.15424968},
    URL = {https://zenodo.org/records/15424968}
}

@article{10.1145/3632889,
    author = {Jacobs, Jules and Hinrichsen, Jonas Kastberg and Krebbers, Robbert},
    title = {Deadlock-Free Separation Logic: Linearity Yields Progress for Dependent Higher-Order Message Passing},
    year = {2024},
    issue_date = {January 2024},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {8},
    number = {POPL},
    url = {https://doi.org/10.1145/3632889},
    doi = {10.1145/3632889},
    abstract = {We introduce a linear concurrent separation logic, called LinearActris, designed to guarantee deadlock and leak freedom for message-passing concurrency. LinearActris combines the strengths of session types and concurrent separation logic, allowing for the verification of challenging higher-order programs with mutable state through dependent protocols. The key challenge is to prove the adequacy theorem of LinearActris, which says that the logic indeed gives deadlock and leak freedom “for free” from linearity. We prove this theorem by defining a step-indexed model of separation logic, based on connectivity graphs. To demonstrate the expressive power of LinearActris, we prove soundness of a higher-order (GV-style) session type system using the technique of logical relations. All our results and examples have been mechanized in Coq.},
    journal = {Proc. ACM Program. Lang.},
    month = jan,
    articleno = {47},
    numpages = {33},
    keywords = {Message passing, deadlocks, session types, separation logic, Iris, Coq}
}


@article{10.1145/3290341,
    author = {Fowler, Simon and Lindley, Sam and Morris, J. Garrett and Decova, S\'{a}ra},
    title = {Exceptional asynchronous session types: session types without tiers},
    year = {2019},
    issue_date = {January 2019},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {3},
    number = {POPL},
    url = {https://doi.org/10.1145/3290341},
    doi = {10.1145/3290341},
    abstract = {Session types statically guarantee that communication complies with a protocol. However, most accounts of session typing do not account for failure, which means they are of limited use in real applications---especially distributed applications---where failure is pervasive.  We present the first formal integration of asynchronous session types with exception handling in a functional programming language. We define a core calculus which satisfies preservation and progress properties, is deadlock free, confluent, and terminating.  We provide the first implementation of session types with exception handling for a fully-fledged functional programming language, by extending the Links web programming language; our implementation draws on existing work on effect handlers. We illustrate our approach through a running example of two-factor authentication, and a larger example of a session-based chat application where communication occurs over session-typed channels and disconnections are handled gracefully.},
    journal = {Proc. ACM Program. Lang.},
    month = jan,
    articleno = {28},
    numpages = {29},
    keywords = {web programming, session types, exceptions, asynchrony}
}

@misc{graversen2025promisingfutureomissionfailures,
    title={A Promising Future: Omission Failures in Choreographic Programming},
    author={Eva Graversen and Fabrizio Montesi and Marco Peressotti},
    year={2025},
    eprint={1712.05465},
    archivePrefix={arXiv},
    primaryClass={cs.PL},
    url={https://arxiv.org/abs/1712.05465},
}

@inproceedings{10.1145/2804302.2804319,
    author = {Kiselyov, Oleg and Ishii, Hiromi},
    title = {Freer monads, more extensible effects},
    year = {2015},
    isbn = {9781450338080},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2804302.2804319},
    doi = {10.1145/2804302.2804319},
    abstract = {We present a rational reconstruction of extensible effects, the recently proposed alternative to monad transformers, as the confluence of efforts to make effectful computations compose. Free monads and then extensible effects emerge from the straightforward term representation of an effectful computation, as more and more boilerplate is abstracted away. The generalization process further leads to freer monads, constructed without the Functor constraint. The continuation exposed in freer monads can then be represented as an efficient type-aligned data structure. The end result is the algorithmically efficient extensible effects library, which is not only more comprehensible but also faster than earlier implementations. As an illustration of the new library, we show three surprisingly simple applications: non-determinism with committed choice (LogicT), catching IO exceptions in the presence of other effects, and the semi-automatic management of file handles and other resources through monadic regions. We extensively use and promote the new sort of `laziness', which underlies the left Kan extension: instead of performing an operation, keep its operands and pretend it is done.},
    booktitle = {Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell},
    pages = {94–105},
    numpages = {12},
    keywords = {Kan extension, coroutine, effect handler, effect interaction, free monad, open union, type and effect system},
    location = {Vancouver, BC, Canada},
    series = {Haskell '15}
}


@article{keizer2023implementing,
    Author = {Alex C. Keizer},
    Title = {Implementing a definitional (co)datatype package in Lean~4, based on quotients of polynomial functors},
    Journal = {ILLC Eprints / Master of Logic Thesis Series},
    Year = {2023},
    URL = {https://eprints.illc.uva.nl/id/eprint/2239/}
}

@article{10.1145/3371119,
    author = {Xia, Li-yao and Zakowski, Yannick and He, Paul and Hur, Chung-Kil and Malecha, Gregory and Pierce, Benjamin C. and Zdancewic, Steve},
    title = {Interaction trees: representing recursive and impure programs in Coq},
    year = {2019},
    issue_date = {January 2020},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {4},
    number = {POPL},
    url = {https://doi.org/10.1145/3371119},
    doi = {10.1145/3371119},
    abstract = {Interaction trees (ITrees) are a general-purpose data structure for representing the behaviors of recursive programs that interact with their environments. A coinductive variant of “free monads,” ITrees are built out of uninterpreted events and their continuations. They support compositional construction of interpreters from event handlers, which give meaning to events by defining their semantics as monadic actions. ITrees are expressive enough to represent impure and potentially nonterminating, mutually recursive computations, while admitting a rich equational theory of equivalence up to weak bisimulation. In contrast to other approaches such as relationally specified operational semantics, ITrees are executable via code extraction, making them suitable for debugging, testing, and implementing software artifacts that are amenable to formal verification. We have implemented ITrees and their associated theory as a Coq library, mechanizing classic domain- and category-theoretic results about program semantics, iteration, monadic structures, and equational reasoning. Although the internals of the library rely heavily on coinductive proofs, the interface hides these details so that clients can use and reason about ITrees without explicit use of Coq’s coinduction tactics. To showcase the utility of our theory, we prove the termination-sensitive correctness of a compiler from a simple imperative source language to an assembly-like target whose meanings are given in an ITree-based denotational semantics. Unlike previous results using operational techniques, our bisimulation proof follows straightforwardly by structural induction and elementary rewriting via an equational theory of combinators for control-flow graphs.},
    journal = {Proc. ACM Program. Lang.},
    month = dec,
    articleno = {51},
    numpages = {32},
    keywords = {monads, compiler correctness, coinduction, Coq}
}

@article{10.1145/3747538,
    author = {Plyukhin, Dan and Qin, Xueying and Montesi, Fabrizio},
    title = {Relax! The Semilenient Core of Choreographic Programming (Functional Pearl)},
    year = {2025},
    issue_date = {August 2025},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {9},
    number = {ICFP},
    url = {https://doi.org/10.1145/3747538},
    doi = {10.1145/3747538},
    abstract = {The past few years have seen a surge of interest in choreographic programming, a programming paradigm for concurrent and distributed systems. The paradigm allows programmers to implement a distributed interaction protocol with a single high-level program, called a choreography, and then mechanically project it into correct implementations of its participating processes. A choreography can be expressed as a λ-term parameterized by constructors for creating data “at” a process and for communicating data between processes. Through this lens, recent work has shown how one can add choreographies to mainstream languages like Java, or even embed choreographies as a DSL in languages like Haskell and Rust. These new choreographic languages allow programmers to write in applicative style (like in functional programming) and write higher-order choreographies for better modularity. But the semantics of functional choreographic languages is not well-understood. Whereas typical λ-calculi can have their operational semantics defined with just a few rules, existing models for choreographic λ-calculi have dozens of complex rules and no clear or agreed-upon evaluation strategy. We show that functional choreographic programming is simple. Beginning with the Chorλ model from previous work, we strip away inessential features to produce a “core” model called λχ. We discover that underneath Chorλ’s apparently ad-hoc semantics lies a close connection to non-strict λ-calculi; we call the resulting evaluation strategy semilenient. Then, inspired by previous non-strict calculi, we develop a notion of choreographic evaluation contexts and a special commute rule to simplify and explain the unusual semantics of functional choreographic languages. The extra structure leads us to a presentation of λχ with just ten rules, and a discovery of three missing rules in previous presentations of Chorλ. We also show how the extra structure comes with nice properties, which we use to simplify the correspondence proof between choreographies and their projections. Our model serves as both a principled foundation for functional choreographic languages and a good entry point for newcomers.},
    journal = {Proc. ACM Program. Lang.},
    month = aug,
    articleno = {269},
    numpages = {27},
    keywords = {Choreographies, Concurrency, λ-calculus}
}



@article{10.1145/3547638,
    author = {Jacobs, Jules and Balzer, Stephanie and Krebbers, Robbert},
    title = {Multiparty GV: functional multiparty session types with certified deadlock freedom},
    year = {2022},
    issue_date = {August 2022},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {6},
    number = {ICFP},
    url = {https://doi.org/10.1145/3547638},
    doi = {10.1145/3547638},
    abstract = {Session types have recently been integrated with functional languages, bringing message-passing concurrency to functional programming.   Channel endpoints then become first-class and can be stored in data structures, captured in closures, and sent along channels.   Representatives of the GV (Wadler's "Good Variation") session type family are of particular appeal because they not only assert session fidelity but also deadlock freedom, inspired by a Curry-Howard correspondence to linear logic.   A restriction of current versions of GV, however, is the focus on binary sessions, limiting concurrent interactions within a session to two participants.   This paper introduces Multiparty GV (MPGV), a functional language with multiparty session types, allowing concurrent interactions among several participants.   MPGV upholds the strong guarantees of its ancestor GV, including deadlock freedom, despite session interleaving and delegation.   MPGV has a novel redirecting construct for modular programming with first-class endpoints,  thanks to which we give a type-preserving translation from binary session types to MPGV to show that MPGV is strictly more general than binary GV.   All results in this paper have been mechanized using the Coq proof assistant.},
    journal = {Proc. ACM Program. Lang.},
    month = aug,
    articleno = {107},
    numpages = {30},
    keywords = {message-passing concurrency, deadlock freedom, Session types}
}


@article{10.1145/367177.367199,
    author = {McCarthy, John},
    title = {Recursive functions of symbolic expressions and their computation by machine, Part I},
    year = {1960},
    issue_date = {April 1960},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {3},
    number = {4},
    issn = {0001-0782},
    url = {https://doi.org/10.1145/367177.367199},
    doi = {10.1145/367177.367199},
    journal = {Commun. ACM},
    month = apr,
    pages = {184–195},
    numpages = {12}
}

@article{10.1145/7239.7266,
    author = {Mohan, C. and Lindsay, B. and Obermarck, R.},
    title = {Transaction management in the R* distributed database management system},
    year = {1986},
    issue_date = {Dec. 1986},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {11},
    number = {4},
    issn = {0362-5915},
    url = {https://doi.org/10.1145/7239.7266},
    doi = {10.1145/7239.7266},
    abstract = {This paper deals with the transaction management aspects of the R* distributed database system. It concentrates primarily on the description of the R* commit protocols, Presumed Abort (PA) and Presumed Commit (PC). PA and PC are extensions of the well-known, two-phase (2P) commit protocol. PA is optimized for read-only transactions and a class of multisite update transactions, and PC is optimized for other classes of multisite update transactions. The optimizations result in reduced intersite message traffic and log writes, and, consequently, a better response time. The paper also discusses R*'s approach toward distributed deadlock detection and resolution.},
    journal = {ACM Trans. Database Syst.},
    month = dec,
    pages = {378–396},
    numpages = {19}
}

%%
@article{thiemann2023intrinsicallytypedsessionscallbacks,
    title={Intrinsically Typed Sessions With Callbacks},
    author={Peter Thiemann},
    year={2023},
    eprint={2303.01278},
    archivePrefix={arXiv},
    primaryClass={cs.PL},
    url={https://arxiv.org/abs/2303.01278},
}

@article{10.1145/3591277,
    author = {Mordido, Andreia and Spaderna, Janek and Thiemann, Peter and Vasconcelos, Vasco T.},
    title = {Parameterized Algebraic Protocols},
    year = {2023},
    issue_date = {June 2023},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {7},
    number = {PLDI},
    url = {https://doi.org/10.1145/3591277},
    doi = {10.1145/3591277},
    abstract = {We propose algebraic protocols that enable the definition of protocol templates and session types analogous to the definition of domain-specific types with algebraic datatypes. Parameterized algebraic protocols subsume all regular as well as most context-free and nested session types and, at the same time, replace the expensive superlinear algorithms for type checking by a nominal check that runs in linear time. Algebraic protocols in combination with polymorphism increase expressiveness and modularity by facilitating new ways of parameterizing and composing session types.},
    journal = {Proc. ACM Program. Lang.},
    month = jun,
    articleno = {163},
    numpages = {25},
    keywords = {Algebraic datatypes, Isorecursive types, Nominal types, Parameterized protocols, Session types}
}